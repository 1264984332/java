线程生命周期

当线程被new出并start后,他既不是马上就进入执行状态, 也不会一直处于执行状态, 一个线程会经过新建NEW -> 就绪RUNNABLE -> 运行RUNNING -> 阻塞BLOCKED -> 死亡DEAD五种状态切换. 


1. 新建New

当new出一个Thread后,该线程处于新建状态,此时他和其他Java对象一样,仅由JVM为其分配内存.并没有表现出任何线程的动态特征.

2. 就绪Runnable

当线程对象调用start()后,该线程处于就绪状态,JVM会为其创建方法调用栈(Stack Trace)/线程控制块/程序计数器(PC),处于这个状态的线程表示是可以运行的.但何时运行,取决于JVM里线程调度器的调度.

3. 运行Running

如果处于就绪状态的线程一旦获得了CPU,就开始执行run()方法中的线程执行体,则线程进入运行状态.

4. 阻塞Blocked

当发生如下情况时,线程会进入阻塞状态

线程调用sleep()主动放弃处理器;
线程调用阻塞IO, 其IO资源未到;
线程试图获得同步监视器, 但同步监视器被其他线程持有;
线程等待某个通知wait();
调用了线程的suspend()方法(该方法将导致线程挂起,但这样容易导致死锁,不建议使用[详细见线程同步]).
当前线程被阻塞之后, 其他线程就可以获得执行的机会.
当发生如下情况, 线程可以解除阻塞, 重新进入就绪:

线程sleep()到达指定时间;
阻塞IO返回;
成功获得同步监视器;
线程收到了其他线程发出的通知notify();
被suspend()的线程被调用了resume()恢复方法;
被阻塞的线程会在合适的时候重新进入就绪状态.
5. 线程死亡

run() / call()方法执行完成, 线程正常结束;
线程抛出未捕获的Exception或Error;
直接调用线程的stop()方法结束该线程(该方法容易导致死锁,不建议使用).
一旦子线程启动起来后,就拥有和父线程相同的地位,不会受父线程的任何影响(因此当主线程结束时,其他线程不会同主线程一起结束).
为了测试某个线程是否生存, 可以调用Thread实例的isAlive()方法(就绪/运行/阻塞返回true, 新建/死亡返回false).

不要试图对已经死亡的线程调用start()方法, 死亡线程将不可再次作为线程执行.否则会抛出java.lang.IllegalThreadStateException.